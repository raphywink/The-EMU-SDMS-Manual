[
["app-chap-wrassp.html", "19 wrassp 19.1 Using Praat’s signal processing routines in the EMU-SDMS 19.2 Using OpenSMILE signal processing routines in the EMU-SDMS", " 19 wrassp 19.1 Using Praat’s signal processing routines in the EMU-SDMS 19.1.1 To Formant (burg)... to SSFF files The R code snippet below shows how generating an AsspDataObj from scratch can be used in a function to place data from other sources into SSFF files. In this case it uses the PraatR R package (see http://www.aaronalbin.com/praatr/index.html) to execute Praat’s \"To Formant (burg)...\" function to then store the data to a comma separated file using \"Down to Table...\". The generated table is then read into R and the appropriate columns are placed into tracks of a AsspDataObj object. The PraatToFormants2AsspDataObj can be viewed as a template function as it can easily be adapted to use other functions provided by Praat or even other external tools. ################################### # uncomment and execute the next # two lines to install PraatR # library(devtools) # install_github(&#39;usagi5886/PraatR&#39;) library(PraatR) ##&#39; Call Praat&#39;s To Formant (burg)... function and ##&#39; convert the output to an AsspDataObj object ##&#39; @param path path to wav file ##&#39; @param command Praat command to use ##&#39; @param arguments arguments passed to \\code{PraatR::praat()} arguments argument ##&#39; @param columnNames specify column names of AsspDataObj praatToFormants2AsspDataObj &lt;- function(path, command = &quot;To Formant (burg)...&quot;, arguments = list(0.0, 5, 5500, 0.025, 50), columnNames = c(&quot;fm&quot;, &quot;bw&quot;)){ tmp1FileName = &quot;tmp.ooTextFile&quot; tmp2FileName = &quot;tmp.table&quot; tmp1FilePath = file.path(tempdir(), tmp1FileName) tmp2FilePath = file.path(tempdir(), tmp2FileName) # remove tmp files if they already exist unlink(file.path(tempdir(), tmp1FileName)) unlink(file.path(tempdir(), tmp2FileName)) # generate ooTextFile PraatR::praat(command = command, input=path, arguments = arguments, output = tmp1FilePath) # convert to Table PraatR::praat(&quot;Down to Table...&quot;, input = tmp1FilePath, arguments = list(F, T, 6, F, 3, T, 3, T), output = tmp2FilePath, filetype=&quot;comma-separated&quot;) # get vals df = read.csv(tmp2FilePath, stringsAsFactors=FALSE) df[df == &#39;--undefined--&#39;] = 0 fmVals = df[,c(3, 5, 7, 9, 11)] fmVals = sapply(colnames(fmVals), function(x){ as.integer(fmVals[,x]) }) colnames(fmVals) = NULL bwVals = data.matrix(df[,c(4, 6, 8, 10, 12)]) bwVals = sapply(colnames(bwVals), function(x){ as.integer(bwVals[,x]) }) colnames(bwVals) = NULL # get start time startTime = df[1,1] # create AsspDataObj ado = list() attr(ado, &quot;trackFormats&quot;) =c(&quot;INT16&quot;, &quot;INT16&quot;) if(arguments[[1]] == 0){ sR = 1 / (0.25 * arguments[[4]]) }else{ sR = 1 / arguments[[1]] } attr(ado, &quot;sampleRate&quot;) = sR tmpObj = wrassp::read.AsspDataObj(path) attr(ado, &quot;origFreq&quot;) = attr(tmpObj, &quot;sampleRate&quot;) attr(ado, &quot;startTime&quot;) = startTime # attr(ado, &quot;startRecord&quot;) = as.integer(1) attr(ado, &quot;endRecord&quot;) = as.integer(nrow(fmVals)) class(ado) = &quot;AsspDataObj&quot; wrassp::AsspFileFormat(ado) &lt;- &quot;SSFF&quot; wrassp::AsspDataFormat(ado) &lt;- as.integer(2) # == binary ado = wrassp::addTrack(ado, columnNames[1], fmVals, &quot;INT16&quot;) ado = wrassp::addTrack(ado, columnNames[2], bwVals, &quot;INT16&quot;) # add missing values at the start as Praat sometimes # has very late start values which causes issues # in the SSFF file format as this sets the startRecord # depending on the start time of the first sample if(startTime &gt; 1/sR){ nr_of_missing_samples = floor(startTime / (1/sR)) missing_fm_vals = matrix(0, nrow = nr_of_missing_samples, ncol = ncol(ado$fm)) missing_bw_vals = matrix(0, nrow = nr_of_missing_samples, ncol = ncol(ado$bw)) # prepend values ado$fm = rbind(missing_fm_vals, ado$fm) ado$bw = rbind(missing_fm_vals, ado$bw) # fix start time attr(ado, &quot;startTime&quot;) = startTime - nr_of_missing_samples * (1/sR) } return(ado) } How this function can be applied to wav files of an emuDB is shown below. library(emuR) # create demo data in tempdir() create_emuRdemoData(tempdir()) # create path to demo database path2ae = file.path(tempdir(), &quot;emuR_demoData&quot;, &quot;ae_emuDB&quot;) # list all .wav files in the ae emuDB paths2wavFiles = list.files(path2ae, pattern = &quot;*.wav$&quot;, recursive = TRUE, full.names = TRUE) # loop through files for(fp in paths2wavFiles){ ado = praatToFormants2AsspDataObj(fp) newPath = paste0(tools::file_path_sans_ext(fp), &#39;.praatFms&#39;) # print(paste0(fp, &#39; -&gt; &#39;, newPath)) # uncomment for simple log wrassp::write.AsspDataObj(ado, file = newPath) } # load emuDB ae = load_emuDB(path2ae, verbose = FALSE) # add SSFF track definition add_ssffTrackDefinition(ae, name = &quot;praatFms&quot;, columnName = &quot;fm&quot;, fileExtension = &quot;praatFms&quot;) # test query + get_trackdata sl = query(ae, &quot;Phonetic == n&quot;) td = get_trackdata(ae, sl, ssffTrackName = &quot;praatFms&quot;, verbose = F) 19.1.2 To Pitch... to SSFF files The R code snippet below does the following: calculates f0 via Praat’s “To Pitch…” command; smooths the f0 contour via Praat’s “Smooth” command, if parameter “smooth” is set to TRUE creates a PitchTier and then a TableOfReal converts all of this into an AsspDataObj (which later on can be saved as an SSFF-file.) A few comments about synchronized F0 and Formant values, whenever praatToFormants2AsspDataObj() and praatToPitch2AsspDataObj() are involved: Be careful with the arguments list: The first entry is \"Time step (s) (standard value: 0.0) the measurement interval (frame duration), in seconds. If you supply 0, Praat will use a time step of 0.75 / (pitch floor), e.g. 0.01 seconds if the pitch floor is 75 Hz; in this example, Praat computes 100 pitch values per second. \" Here parameter 1 - Time step - is set to 0.00625 (Seconds) (as opposed to Praat’s default of 0.0) in order to keep it in line with Time step in “To Formant…”, because Time step in “To Formants…” is derived from window length (which in “To Formant…” defaults to 0.025) (window length/4 (–&gt; Time step in “To Formant…” will usually be 0.00625)) The second parameter \"Pitch floor (Hz) (standard value: 75 Hz): candidates below this frequency will not be recruited. This parameter determines the length of the analysis window: it will be 3 longest periods long, i.e., if the pitch floor is 75 Hz, the window will be 3/75 = 0.04 seconds long. Note that if you set the time step to zero, the analysis windows for consecutive measurements will overlap appreciably: Praat will always compute 4 pitch values within one window length, i.e., the degree of oversampling is 4.\" Importantly, this parameter is set NOT to praat’s default 75 Hz, but to 60 Hz, again because of correspondance of window lengths between “To Pitch…” and “To Formants…”. The actual window length in “To Formants…” will be twice as long as the value given in the “To Formants…” command, i.e. the default of 0.025 will result in a window length of 0.05. A window length in “To Pitch…” can indirectly achieved by using a pitch floor value of 60 Hz (given that 3/60 = 0.05). In most cases, differing window lengths will not affect the temporal position of the F0 and Formant values, however, due to problems near the edges, sometimes they will (and therefore result in non-synchronized F0 and Formant values). Due to rounding errors, F0 and Formant values still might be slightly asynchronous; to avoid this, praatToPitch2AsspDataObj() rounds the start time with a precicion of 0.001 ms (via round(attr(ado, “startTime”),6) in the very end). The third parameter (default: 600) is the pitch ceiling (and this parameter will not affect any other parameters indirectly) ################################### # uncomment and execute the next # two lines to install PraatR # library(devtools) # install_github(&#39;usagi5886/PraatR&#39;) library(PraatR) ##&#39; Call Praat&#39;s To Pitch... function and ##&#39; convert the output to an AsspDataObj object ##&#39; @param path path to wav file ##&#39; @param command Praat command to use ##&#39; @param arguments arguments passed to \\code{PraatR::praat()} arguments argument ##&#39; @param columnNames specify column names of AsspDataObj ##&#39; @param smooth apply Praat&#39;s &quot;Smooth&quot; command praatToPitch2AsspDataObj &lt;- function(path, command = &quot;To Pitch...&quot;, arguments = list(0.00625, 60.0, 600.0), columnNames = c(&quot;f0&quot;), smooth = TRUE){ tmp1FileName = &quot;tmp.ooTextFile&quot; tmp2FileName = &quot;tmp2.ooTextFile&quot; tmp3FileName = &quot;tmp3.PitchTier&quot; tmp4FileName = &quot;tmp4.txt&quot; tmp1FilePath = file.path(tempdir(), tmp1FileName) tmp2FilePath = file.path(tempdir(), tmp2FileName) tmp3FilePath = file.path(tempdir(), tmp3FileName) tmp4FilePath = file.path(tempdir(), tmp4FileName) # remove tmp files if they already exist unlink(file.path(tempdir(), tmp1FileName)) unlink(file.path(tempdir(), tmp2FileName)) unlink(file.path(tempdir(), tmp3FileName)) unlink(file.path(tempdir(), tmp4FileName)) # generate ooTextFile PraatR::praat(command = command, input=path, arguments = arguments, output = tmp1FilePath, overwrite = TRUE) if (smooth){ PraatR::praat(&quot;Smooth...&quot;, input = tmp1FilePath, arguments = list(10), output = tmp2FilePath, overwrite = TRUE) } else { tmp2FilePath = tmp1FilePath } nframes = as.numeric(PraatR::praat(&quot;Get number of frames&quot;, input = tmp2FilePath, simplify = TRUE)) timestep = as.numeric((PraatR::praat(&quot;Get time step&quot;, input = tmp2FilePath, simplify = TRUE))) sR = 1/timestep start = as.numeric((PraatR::praat(&quot;Get time from frame number...&quot;, input = tmp2FilePath, simplify = TRUE, arguments = list(1)))) end = as.numeric((PraatR::praat(&quot;Get time from frame number...&quot;, input = tmp2FilePath, simplify = TRUE, arguments = list(nframes)))) # convert to PitchTier PraatR::praat(&quot;Down to PitchTier&quot;, input = tmp2FilePath, output = tmp3FilePath, overwrite = TRUE) # Down to TableOfReal: &quot;Hertz&quot; PraatR::praat(&quot;Down to TableOfReal...&quot;, input = tmp3FilePath, output = tmp4FilePath, arguments = list(&quot;Hertz&quot;), filetype = &quot;headerless spreadsheet&quot;, overwrite = TRUE) # create empty df that holds all time steps df = data.frame(Time = seq(start, end, by = timestep), F0 = 0) # get vals df_tmp = read.csv(tmp4FilePath, stringsAsFactors = FALSE, sep = &quot;\\t&quot;)[,2:3] # and fill up empty df (ensures every timestep has a value) df$F0[df$Time %in% df_tmp$Time] = df_tmp$F0 df # create AsspDataObj ado = list() attr(ado, &quot;trackFormats&quot;) = c(&quot;INT16&quot;) attr(ado, &quot;sampleRate&quot;) = sR tmpObj = wrassp::read.AsspDataObj(path) attr(ado, &quot;origFreq&quot;) = attr(tmpObj, &quot;sampleRate&quot;) attr(ado, &quot;startTime&quot;) = start attr(ado, &quot;endRecord&quot;) = as.integer(nframes) class(ado) = &quot;AsspDataObj&quot; wrassp::AsspFileFormat(ado) &lt;- &quot;SSFF&quot; wrassp::AsspDataFormat(ado) &lt;- as.integer(2) f0Vals = as.integer(df[,&quot;F0&quot;]) ado = wrassp::addTrack(ado, &quot;f0&quot;, f0Vals, &quot;INT16&quot;) # prepend missing values as praat sometimes # starts fairly late if(start &gt; 1 / sR){ nr_of_missing_samples = floor(start / (1/sR)) missing_f0_vals = matrix(0, nrow = nr_of_missing_samples, ncol = ncol(ado$f0)) # prepend values ado$f0 = rbind(missing_f0_vals, ado$f0) # fix start time attr(ado, &quot;startTime&quot;) = start - nr_of_missing_samples * (1 / sR) attr(ado, &quot;startTime&quot;) = round(attr(ado, &quot;startTime&quot;), 6) } return(ado) } How this function can be applied to wav files of an emuDB is shown below. library(emuR) # create demo data in tempdir() create_emuRdemoData(tempdir()) # create path to demo database path2ae = file.path(tempdir(), &quot;emuR_demoData&quot;, &quot;ae_emuDB&quot;) # test the function of converting praat formant data to emuR paths2wavFiles = list.files(path2ae, pattern = &quot;wav$&quot;, recursive = TRUE, full.names = TRUE) # loop through files for(fp in paths2wavFiles){ ado = praatToPitch2AsspDataObj(fp) newPath = paste0(tools::file_path_sans_ext(fp), &#39;.praatF0&#39;) # print(paste0(fp, &#39; -&gt; &#39;, newPath)) # uncomment for simple log wrassp::write.AsspDataObj(ado, file = newPath) } # load emuDB ae = load_emuDB(path2ae, verbose = FALSE) # add SSFF track definition add_ssffTrackDefinition(ae, name = &quot;praatF0&quot;, columnName = &quot;f0&quot;, fileExtension = &quot;praatF0&quot;) # test query + get_trackdata sl = query(ae, &quot;Phonetic == n&quot;) td = get_trackdata(ae, sl, ssffTrackName = &quot;praatF0&quot;, verbose = F) # configure EMU-webApp to show new track sc_order = get_signalCanvasesOrder(ae, &quot;default&quot;) set_signalCanvasesOrder(ae, &quot;default&quot;, c(sc_order, &quot;praatF0&quot;)) # serve(ae) # uncomment to view in EMU-webApp 19.2 Using OpenSMILE signal processing routines in the EMU-SDMS ##&#39; convert CSV output of SMILExtract to AsspDataObject ##&#39; @param path path to wav file ##&#39; @param SMILExtractPath path to SMILExtract executable ##&#39; @param configPath path to openSMILE config file ##&#39; @param columsAsTracks if TRUE -&gt; every column will be placed in it&#39;s own track ##&#39; if FALSE -&gt; every column is placed into a single track called SMILExtractAll SMILExtract2AsspDataObj &lt;- function(path, SMILExtractPath, configPath, columsAsTracks = TRUE){ tmp1FileName = &quot;tmp.csv&quot; tmp1FilePath = file.path(tempdir(), tmp1FileName) # remove tmp file if it already exists unlink(file.path(tempdir(), tmp1FileName)) system(paste0(SMILExtractPath, &quot; -C &quot;, configPath, &quot; -I &quot;, path, &quot; -O &quot;, tmp1FilePath), ignore.stdout = T, ignore.stderr = T) # get vals df = suppressMessages(readr::read_delim(tmp1FilePath, delim = &quot;;&quot;)) # extract + remove frameIndex/frameTime frameIndex = df$frameIndex frameTime = df$frameTime df$frameIndex = NULL df$frameTime = NULL df = as.matrix(df) colNames = colnames(df) # get start time startTime = frameTime[1] # create AsspDataObj ado = list() attr(ado, &quot;sampleRate&quot;) = 1/frameTime[2] # second frameTime should be stepsize tmpObj = wrassp::read.AsspDataObj(path) attr(ado, &quot;origFreq&quot;) = attr(tmpObj, &quot;sampleRate&quot;) attr(ado, &quot;startTime&quot;) = startTime # attr(ado, &quot;startRecord&quot;) = as.integer(1) attr(ado, &quot;endRecord&quot;) = as.integer(nrow(df)) class(ado) = &quot;AsspDataObj&quot; wrassp::AsspFileFormat(ado) &lt;- &quot;SSFF&quot; wrassp::AsspDataFormat(ado) &lt;- as.integer(2) # add every column as new track if(columsAsTracks){ attr(ado, &quot;trackFormats&quot;) = rep(&quot;REAL32&quot;, ncol(df)) for(i in 1:ncol(df)){ ado = wrassp::addTrack(ado, trackname = colNames[i], data = df[,i], format = &quot;REAL32&quot;) } }else{ attr(ado, &quot;trackFormats&quot;) = &quot;REAL32&quot; ado = wrassp::addTrack(ado, trackname = &quot;SMILExtractAll&quot;, data = df, format = &quot;REAL32&quot;) } return(ado) } How this function can be applied to wav files of an emuDB is shown below. library(emuR) # create demo data in tempdir() create_emuRdemoData(tempdir()) # create path to demo database path2ae = file.path(tempdir(), &quot;emuR_demoData&quot;, &quot;ae_emuDB&quot;) # list all .wav files in the ae emuDB paths2wavFiles = list.files(path2ae, pattern = &quot;*.wav$&quot;, recursive = TRUE, full.names = TRUE) # loop through files for(fp in paths2wavFiles){ ado = SMILExtract2AsspDataObj(fp, SMILExtractPath = &quot;~/programs/opensmile-2.3.0/bin/SMILExtract&quot;, configPath = &quot;~/programs/opensmile-2.3.0/config/demo/demo1_energy.conf&quot;) newPath = paste0(file_path_sans_ext(fp), &#39;.SMILExtract&#39;) # print(paste0(fp, &#39; -&gt; &#39;, newPath)) # uncomment for simple log write.AsspDataObj(ado, file = newPath) } # load emuDB ae = load_emuDB(path2ae, verbose = FALSE) # add SSFF track definition add_ssffTrackDefinition(ae, name = &quot;SMILExtract&quot;, columnName = &quot;pcm_LOGenergy&quot;, fileExtension = &quot;SMILExtract&quot;) # test query + get_trackdata sl = query(ae, &quot;Phonetic == n&quot;) td = get_trackdata(ae, sl, ssffTrackName = &quot;SMILExtract&quot;, verbose = F) # test display set_signalCanvasesOrder(ae, perspectiveName = &quot;default&quot;, order = c(&quot;OSCI&quot;, &quot;SPEC&quot;, &quot;SMILExtract&quot;)) # serve(ae) # uncomment to view in EMU-webApp "]
]
